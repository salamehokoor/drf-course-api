from rest_framework import serializers
from .models import Order, Product, OrderItem
"""
Converting model instances to JSON (so you can send them in an API response).
Validating and converting incoming JSON to model instances (so you can save data from API requests).
"""


class ProductSerializer(serializers.ModelSerializer):

    class Meta:
        model = Product  # → this serializer is for the Product model.
        fields = (
            'name', 'description', 'price', 'stock'
        )  # → these are the model fields you want to include in the API.

    def validate_price(self, value):
        if value < 0:
            raise serializers.ValidationError(
                "Price must be a positive value.")
        return value

    #if we want to have the id in the get request we need to make a specific serializer for the post requestbecause we cant ask the user
    #to provide the id when creating a new product it must be autogenerated
    #DRF automatically calls validate_<fieldname> for the field when data is being deserialized or saved via the API.


class OrderItemSerializer(serializers.ModelSerializer):
    product_name = serializers.CharField(source='product.name')
    product_price = serializers.DecimalField(
        max_digits=10,
        decimal_places=2,
        source='product.price',
    )

    #product = ProductSerializer(read_only=True) this shows the entire product object inside the order item
    class Meta:
        model = OrderItem
        fields = (
            'product_name',
            'product_price',
            'quantity',
            'item_subtotal',
            #This means that every time Django (or DRF) accesses order_item.item_subtotal,
            #it calls this method automatically and returns the calculated value.
        )


class OrderCreateSerializer(serializers.ModelSerializer):

    class OrderItemCreateSerializer(serializers.ModelSerializer):

        class Meta:
            model = OrderItem
            fields = ('product', 'quantity')

    order_id = serializers.UUIDField(read_only=True)
    items = OrderItemSerializer(many=True)

    def create(self, validated_data):
        order_item_data = validated_data.pop('items')
        order = Order.objects.create(**validated_data)
        for item in order_item_data:
            OrderItem.objects.create(order=order, **item)
        return Order

    class Meta:
        model = Order
        fields = (
            'order_id',
            'user',
            'status',
            'items',
        )

    extra_kwargs = {'user': {'read_only': True}}


class OrderSerializer(serializers.ModelSerializer):
    order_id = serializers.UUIDField(read_only=True)
    #read_only=True → user cannot modify it; it's generated by the system.
    items = OrderItemSerializer(many=True, read_only=True)
    #Django automatically knows which OrderItems belong to a specific Order because of the foreign key relationship defined in your model.
    #in the model we have something like this  order = models.ForeignKey(Order, related_name="items", on_delete=models.CASCADE)
    #This line creates a link:
    #Each OrderItem belongs to one Order
    #Order.items represents all OrderItems belonging to that Order
    total_price = serializers.SerializerMethodField(method_name='total')

    #Adds a computed field called total_price to the API response.
    #It does not exist in the database, it's calculated dynamically.
    #Tells DRF to call the method named total() to get the value.

    def total(self, obj):
        """
        This method is automatically called by DRF when serializing each Order.
        obj → is the actual Order instance being serialized.
        """
        order_items = obj.items.all()
        #Fetches all OrderItem objects related to this order.
        #Uses the reverse relationship (items).
        return sum(order_item.item_subtotal for order_item in order_items)

    class Meta:
        model = Order
        fields = (
            'order_id',
            'user',
            'status',
            'created_at',
            'items',
            'total_price',
        )


class ProductInfoSerializer(serializers.Serializer):
    """
    get all products, count of products, max_price
    Meta is used only in ModelSerializer to tell DRF which model and which fields to serialize.
    But in ProductInfoSerializer, youre not representing a single model instance.
    Youre representing a custom structure
    This data doesn’t exist as a single model in your database, so there’s no Meta class to define.
    """
    products = ProductSerializer(many=True)
    count = serializers.IntegerField()
    max_price = serializers.FloatField()
