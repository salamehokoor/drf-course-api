from rest_framework import serializers
from .models import Order, Product, OrderItem
"""
Converting model instances to JSON (so you can send them in an API response).
Validating and converting incoming JSON to model instances (so you can save data from API requests).
"""


class ProductSerializer(serializers.ModelSerializer):

    class Meta:
        model = Product  # → this serializer is for the Product model.
        fields = (
            'name', 'description', 'price', 'stock'
        )  # → these are the model fields you want to include in the API.

    def validate_price(self, value):
        if value < 0:
            raise serializers.ValidationError(
                "Price must be a positive value.")
        return value

    #if we want to have the id in the get request we need to make a specific serializer for the post requestbecause we cant ask the user
    #to provide the id when creating a new product it must be autogenerated
    #DRF automatically calls validate_<fieldname> for the field when data is being deserialized or saved via the API.


class OrderItemSerializer(serializers.ModelSerializer):
    product_name = serializers.CharField(source='product.name')
    product_price = serializers.DecimalField(
        max_digits=10,
        decimal_places=2,
        source='product.price',
    )

    #product = ProductSerializer(read_only=True) this shows the entire product object inside the order item
    class Meta:
        model = OrderItem
        fields = (
            'product_name',
            'product_price',
            'quantity',
            'item_subtotal',
            #This means that every time Django (or DRF) accesses order_item.item_subtotal,
            #it calls this method automatically and returns the calculated value.
        )


class OrderSerializer(serializers.ModelSerializer):
    items = OrderItemSerializer(many=True, read_only=True)
    #DRF fetches all OrderItems related to this order using order.items.all().
    #Each OrderItem is serialized using OrderItemSerializer
    total_price = serializers.SerializerMethodField(method_name='total')

    #Defines a custom computed field that doesn’t exist in the database.
    #DRF will call a method named get_total_price(self, obj) to calculate its value.

    def total(self, obj):
        """
        This method is automatically called by DRF when serializing each Order.
        obj → is the actual Order instance being serialized.
        """
        order_items = obj.items.all()
        #Fetches all OrderItem objects related to this order.
        #during total(), we’re computing data based on the model instance, not on already-serialized data.
        return sum(order_item.item_subtotal for order_item in order_items)

    class Meta:
        model = Order
        fields = (
            'order_id',
            'user',
            'status',
            'created_at',
            'items',
            'total_price',
        )


class ProductInfoSerializer(serializers.Serializer):
    """
    get all products, count of products, max_price
    Meta is used only in ModelSerializer to tell DRF which model and which fields to serialize.
    But in ProductInfoSerializer, youre not representing a single model instance.
    Youre representing a custom structure
    This data doesn’t exist as a single model in your database, so there’s no Meta class to define.
    """
    products = ProductSerializer(many=True)
    count = serializers.IntegerField()
    max_price = serializers.FloatField()
